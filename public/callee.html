<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nofelet</title>
    <link rel="stylesheet" href="./style.css">
</head>
<body>

<main class="call-container">
    <div class="video-grid">
        <div class="video-wrapper">
            <div class="badge">
                <span class="user-icon">●</span>
                <span class="status">Собеседник</span>
            </div>
            <video id="remoteVideo" autoplay playsinline></video>
        </div>

        <div class="video-wrapper">
            <div class="badge">
                <span class="user-icon">○</span>
                <span class="status">Вы</span>
                <span class="voice-indicator"></span>
            </div>
            <video id="localVideo" autoplay playsinline muted></video>
        </div>
    </div>

    <!-- Круглые кнопки в стиле Google Meet -->
    <nav class="controls">
        <button onclick="acceptCall()" class="btn-round btn-start" id="acceptCallBtn" title="Начать">Start</button>
        <button onclick="soundOff()" class="btn-round btn-toggle" id="soundToggle" title="Микрофон">Mic</button>
        <button onclick="videoOff()" class="btn-round btn-toggle" id="videoToggle" title="Камера">Cam</button>
        <button onclick="disconnect()" class="btn-round btn-end" id="hangUpBtn" title="Завершить">End</button>
    </nav>
</main>

<!-- WebRTC логика-->
<script>
    // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
    let pc;
    let ws;
    let localStream;
    let pendingOffer;
    let iceCandidatesQueue = [];
    let uuid = new URLSearchParams(window.location.search).get('uuid');

    // КОНФИГУРАЦИЯ С TURN СЕРВЕРАМИ
    const configuration = {
        iceTransportPolicy: 'relay',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
    };

    function log(...a) { console.log('[CALLER]', ...a); }

    // ЗАПРОС ВРЕМЕННЫХ КРЕДОВ ДЛЯ TURN
    async function getTurn() {
        return new Promise((resolve, reject) => {
            const s = new WebSocket('wss://nofelet.duckdns.org:8443/turn-credentials/generate');
            s.onmessage = e => {
                resolve(JSON.parse(e.data).iceServers);
                s.close();
            };
            s.onerror = reject;
        });
    }

    // КОННЕКТ К СИГНАЛЬНОМУ СЕРВЕРУ
    async function connect() {
        ws = new WebSocket(`wss://nofelet.duckdns.org:8443/connect/${uuid}`);

        ws.onmessage = async e => {
            const msg = JSON.parse(e.data);

            if (msg.type === 'offer') {
                log('offer received');
                pendingOffer = msg;
                const btn = document.getElementById('acceptCallBtn');
                btn.disabled = false;
                btn.classList.add('ringing');
            }

            if (msg.type === 'ice-candidate') {
                if (pc?.remoteDescription) {
                    await pc.addIceCandidate(msg.candidate);
                } else {
                    iceCandidatesQueue.push(msg.candidate);
                }
            }
        };
    }


    // ПРИНИМАЕМ ВХОДЯЩИЙ ЗВОНОК
    async function acceptCall() {
        const btn = document.getElementById('acceptCallBtn');
        btn.classList.remove('ringing');

        document.getElementById('acceptCallBtn').disabled = true;

        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById('localVideo').srcObject = localStream;

        configuration.iceServers = await getTurn();
        pc = new RTCPeerConnection(configuration);

        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

        pc.ontrack = e => document.getElementById('remoteVideo').srcObject = e.streams[0];

        pc.onicecandidate = e => {
            if (e.candidate) {
                ws.send(JSON.stringify({ type: 'ice-candidate', candidate: e.candidate }));
            }
        };

        pc.onconnectionstatechange = () =>
            log('connectionState:', pc.connectionState);

        await pc.setRemoteDescription({
            type: 'offer',
            sdp: pendingOffer.sdp
        });

        for (const c of iceCandidatesQueue) await pc.addIceCandidate(c);
        iceCandidatesQueue = [];

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        ws.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
    }

    document.getElementById('acceptCallBtn').onclick = acceptCall;

    // ЗАВЕРШЕНИЕ ЗВОНКА
    function disconnect() {
        if (pc) {
            pc.close();
            pc = null;
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
            localStream = null;
        }

        if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
            remoteStream = null;
        }

        iceCandidatesQueue = [];
        document.getElementById('startCallBtn').disabled = true;
        document.getElementById('hangUpBtn').disabled = true;

        if (ws) {
            ws.close(1000, "Normal Closure");
            ws = null;
        }
    }

    // ПЕРЕКЛЮЧАТЕЛЬ СОСТОЯНИЯ КНОПОК ВИДЕО/АУДИО
    function toggleMedia(btn) {
        btn.classList.toggle('off');
    }

    // ОТКЛЮЧЕНИЕ/ВКЛЮЧЕНИЕ ВИДЕО ИНИЦИАТОРА
    function videoOff(){
        const camBtn = document.getElementById('videoToggle');

        toggleMedia(camBtn);

        const toggleButton = document.getElementById('videoToggle');

        const isVideoOn = toggleButton.classList.contains('off');
        if (isVideoOn){
            toggleButton.setAttribute('aria-label', 'Выключить видео');
            localStream.getVideoTracks().forEach(track => {
                track.enabled = false;
            });
        }else {
            localStream.getVideoTracks().forEach(track => {
                track.enabled = true;
            });
        }
    }

    // ОТКЛЮЧЕНИЕ/ВКЛЮЧЕНИЕ АУДИО ИНИЦИАТОРА
    function soundOff(){
        if (!localStream) return;

        // Проверяем текущее состояние первой аудиодорожки (если она есть)
        const audioTracks = localStream.getAudioTracks();
        if (audioTracks.length === 0) return;

        const currentState = audioTracks[0].enabled;
        const newState = !currentState;

        // Переключаем все аудиодорожки
        toggleAudio(localStream, newState);

        const micBtn = document.getElementById('soundToggle');
        toggleMedia(micBtn);
    }

    // ПЕРЕКЛЮЧАТЕЛЬ
    function toggleAudio(stream, enable) {
        if (!stream) return;

        // Получаем все аудиодорожки из потока
        const audioTracks = stream.getAudioTracks();

        // Проходим по всем найденным аудиодорожкам и устанавливаем им enabled
        audioTracks.forEach(track => {
            track.enabled = enable;
            console.log(`Аудиодорожка "${track.label}" теперь ${enable ? 'включена' : 'отключена'}.`);
        });
    }

    window.onload = connect;
</script>

</body>
</html>